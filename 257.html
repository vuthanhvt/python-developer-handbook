
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Robots" content="INDEX,NOFOLLOW">
<META HTTP-EQUIV="Pragma" CONTENT="no-cache">
<TITLE>Safari | Python Developer's Handbook -&gt; Python/C API</TITLE>
<LINK REL="stylesheet" HREF="oreillyi/oreillyN.css">
</HEAD>
<BODY bgcolor="white" text="black" link="#990000" vlink="#990000" alink="#990000" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">

<table width="100%" cellpadding=5 cellspacing=0 border=0 class="navtopbg"><tr><td><font size="1"><p class="navtitle"><a href="8.html" class="navtitle">Web Development</a> &gt; <a href="0672319942.html" class="navtitle">Python Developer's Handbook</a> &gt; <a href="255.html" class="navtitle">A. Python/C API</a> &gt; <span class="nonavtitle">Python/C API</span></p></font></td><td align="right" valign="top" nowrap><font size="1"><a href="main.asp?list" class="safnavoff">See All Titles</a></font></td></tr></table>
<TABLE width=100% bgcolor=white border=0 cellspacing=0 cellpadding=5><TR><TD>
<TABLE border=0 width="100%" cellspacing=0 cellpadding=0><TR><td align=left width="15%" class="headingsubbarbg"><a href="256.html" title="A. Python/C API"><font size="1">&lt;&nbsp;BACK</font></a></td><td align=center width="70%" class="headingsubbarbg"><font size="1"><a href="popanote.asp?pubui=oreilly&bookname=0672319942&snode=257" target="_blank" title="Make a public or private annnotation">Make Note</a> | <a href="257.html" title="Use a Safari bookmark to remember this section">Bookmark</a></font></td><td align=right width="15%" class="headingsubbarbg"><a href="258.html" title="The Very High Level Layer"><font size="1">CONTINUE&nbsp;&gt;</font></a></td></TR></TABLE>
<a href="6%2F1%2F2002+6%3A27%3A44+PM.html" TABINDEX="-1"><img src=images/spacer.gif border=0 width=1 height=1></a><font color=white size=1>152015024128143245168232148039196038240039088173205162105045222218071088187087116113144</font><a href="read4.asp?bookname=0672319942&snode=257&now=6%2F1%2F2002+6%3A27%3A44+PM" TABINDEX="-1"><img src=images/spacer.gif border=0 width=1 height=1></a><br>
<FONT><h3>Python/C API</h3>
				<p>The Application Programmer's Interface to Python gives C and C++ programmers access to the Python interpreter at a variety of levels. The API is equally usable from C++, but for brevity it is generally referred to as the Python/C API. There are two fundamentally different reasons for using the Python/C API. The first reason is to write extension modules for specific purposes; these are C modules that extend the Python interpreter. This is probably the most common use. The second reason is to use Python as a component in a larger application; this technique is generally referred to as embedding Python in an application.</p>

				<P>Writing an extension module is a relatively well-understood process in which a "cookbook" approach works well. Several tools automate the process to some extent. Although people have embedded Python in other applications since its early existence, the process of embedding Python is less straightforward than writing an extension.</P>

				<P>Many API functions are useful independent of whether you're embedding or extending Python; moreover, most applications that embed Python will need to provide a custom extension as well, so it's probably a good idea to become familiar with writing an extension before attempting to embed Python in a real application.</P>

				<p>Python 1.5 introduces a number of new API functions as well as some changes to the build process that make embedding much simpler. This book describes the 1.5.2 state of affairs.</p>

				<h4>Include Files</h4>
					<P>All function, type, and macro definitions needed to use the Python/C API are included in your code by the following line:</P>

					<PRe>
						
#include "Python.h"

					</pre>

					<P>This implies inclusion of the following standard headers: <TT Class="monofont">&lt;stdio.h&gt;,</tt>
						<tt class="monofont">&lt;string.h&gt;,</tt>
						<tt claSs="monofont">&lt;errno.h&gt;,</tT> and <tt cLass="monofont">&lt;stdlib.h&gt;</tT> (if available).</p>

					<p>All user visible names defined by Python.h (except those defined by the included standard headers) have one of the prefixes <tT CLAss="monofont">Py</tt> or <TT CLass="monofont">_Py.</tT> Names beginning with <TT Class="monofont">_Py</TT> are for internal use by the Python implementation and should not be used by extension writers. Structure member names do not have a reserved prefix.</P>

					<P>Important: User code should never define names that begin with <tt class="monofont">Py</tt> or <tt class="monofont">_Py.</tt> This confuses the reader and jeopardizes the portability of the user code to future Python versions, which might define additional names beginning with one of these prefixes.<a nAme="idx1073750764"></A><a naMe="idx1073750765"></a><a nAme="idx1073750766"></a></P>

					<P>The <A Name="idx1073750767"></a><A NAMe="idx1073750768"></a>header files are typically installed with Python. On UNIX, these are located in the directories <tt CLASs="monofont">$prefix/include/pythonversion/</tt> and <tT CLAss="monofont">$exec_prefix/include/ pythonversion/,</tt> where <tt class="monofont">$prefix</tt> and <tt class="monofont">$exec_prefix</Tt> are defined by the corresponding parameters to Python's configure script and the version is <tT claSs="monofont">sys.version[:3].</tt> On Windows, the headers are installed in <tT claSS="monofont">$prefix/include,</TT> where <tt clASS="monofont">$prefix</Tt> is the installation directory specified to the installer.</p>

					<p>To include the headers, place both directories (if different) on your compiler's search path for includes. Do not place the parent directories on the search path and then use <tT CLAss="monofont">#include &lt;python1.5/Python.h&gt;</tt>; this will break on multi-platform builds because the platform independent headers under <TT CLass="monofont">$prefix</tt> include the platform specific headers from <tt class="monofont">$exec_prefix.</tt></p>

				
				<h4>Objects, Types, and Reference Counts</h4>
					<p>Most Python/C API functions have one or more arguments as well as a return value of type <tt ClaSs="monofont">PyObject*.</tt> This type is a pointer to an opaque data type representing an arbitrary Python object. Because all Python object types are treated the same way by the Python language in most situations (for example, assignments, scope rules, and argument passing), it is only fitting that they should be represented by a single C type. Almost all Python objects live on the heap: You never declare an automatic or static variable of type PyObject; only pointer variables of type <Tt claSs="monofont">PyObject*</tt> can be declared. The sole exceptions are the type objects; because these must never be deallocated, they are typically static <TT CLass="monofont">PyTypeObject</tT> objects.</P>

					<P>All Python objects (even Python integers) have a type and a reference count. An object's type determines what kind of object it is (for example, an integer, a list, or a user-defined function; there are many more as explained in the Python Reference Manual). For each of the well-known types, there is a macro to check whether an object is of that type; for instance, <Tt claSS="monofont">PyList_Check(a)</TT> is true if (and only if) the object it points to is a Python list.<a namE="idx1073750769"></A><A Name="idx1073750770"></a><a name="idx1073750771"></a><a name="idx1073750772"></a><a namE="idx1073750773"></a><a Name="idx1073750774"></A></p>

					<h5>Reference Counts</h5>
						<p>The reference count is important because today's computers have a finite (and often severely limited) memory size; it counts how many different places there are that have a reference to an object. Such a place could be another object, a global (or static) C variable, or a local variable in some C function. When an object's reference count becomes zero, the object is deallocated. If it contains references to other objects, their reference count is decremented. Those other objects might be deallocated in turn, if this decrement makes their reference count become zero, and so on. (There's an obvious problem with objects that reference each other here; for now, the solution is don't do that.)</P>

						<p>Reference counts are always manipulated explicitly. The normal way is to use the <a nAME="idx1073750775"></A>macro <a namE="idx1073750776"></A><A Name="idx1073750777"></a><TT CLass="monofont">Py_INCREF()</tT> to increment an object's reference count by one, and <A NAme="idx1073750778"></a><a name="idx1073750779"></a><tt class="monofont">Py_DECREF()</tt> to decrement it by one. The decref macro is considerably more complex than the incref one because it must check whether the reference count becomes zero, and then causes the object's deallocation by calling a function contained in the object's type structure. The type-specific deallocator takes care of <a nAme="idx1073750780"></A>decrementing the reference counts for other objects contained in the object, and so on, if this is a compound object type such as a list. There's no chance that the reference count can overflow; at least as many bits are used to hold the reference count as there are distinct memory locations in virtual memory (assuming <tt cLass="monofont">sizeof(long) &gt;= sizeof(char *)</tT>). Thus, the reference count increment is a simple operation. You should only pass a variable to <tt cLASS="monofont">Py_DECREF</tt> or <a nAME="idx1073750781"></A><a namE="idx1073750782"></A><TT clasS="monofont">Py_XDECREF.</TT> If you pass an expression, it will be evaluated multiple times (so don't use <Tt class="monofont">Py_XDECREF(func(...))</tt> to ignore the return value of a function).<a name="idx1073750783"></a><a name="idx1073750784"></a><A naMe="idx1073750785"></a><a Name="idx1073750786"></a><A namE="idx1073750787"></A><A Name="idx1073750788"></a><A NAMe="idx1073750789"></a></p>

						<p>It is not necessary to <A NAMe="idx1073750790"></a>increment an object's reference count for every local variable that contains a pointer to an object. In theory, the object's reference count goes up by one when the variable is made to point to it, and it goes down by one when the variable goes out of scope. However, these two cancel each other out, so at the end, the reference count hasn't changed. The only real reason to use the reference count is to prevent the object from being deallocated as long as our variable is pointing to it. If we know that there is at least one other reference to the object that lives at least as long as our variable, there is no need to increment the reference count temporarily. An important situation in which this arises is in objects that are passed as arguments to C functions in an extension module that are called from Python; the call mechanism guarantees to hold a reference to every argument for the duration of the call.</p>

						<p>However, a common pitfall is to extract an object from a list and hold on to it for a while without incrementing its reference count. Some other operation might conceivably remove the object from the list, decrementing its reference count, and possibly deallocating it. The real danger is that innocent-looking operations might invoke arbitrary Python code that could do this; there is a code path that allows control to flow back to the user from a <TT CLass="monofont">Py_DECREF(),</tt> so almost any operation is potentially dangerous.</p>

						<p>A safe approach is to always use the generic operations (functions whose name begins with <tt class="monofont">PyObject_,</tt>
							<tt clAss="monofont">PyNumber_,</Tt>
							<tt Class="monofont">PySequence_,</Tt> or <tt CLASs="monofont">PyMapping_</tt>). These operations always increment the reference count of the object they return. This leaves the caller with the responsibility to call <tT CLAss="monofont">Py_DECREF()</tt> when they are done with the result; this soon becomes second nature.<A NAMe="idx1073750791"></a><a nAME="idx1073750792"></A><a name="idx1073750793"></a><a name="idx1073750794"></a></p>

						<h5>Reference Count Details</h5>
							<p>The reference count behavior of <a namE="idx1073750795"></a>functions in the Python/C API is best explained in terms of ownership of references. Note that we talk of owning references, never of owning objects; objects are always shared. When a function owns a reference, it has to dispose of it properly—either by passing ownership on (usually to its caller) or by calling <tT claSs="monofont">Py_DECREF()</tt> or <a Name="idx1073750796"></A><A NAme="idx1073750797"></a><tT CLAss="monofont">Py_XDECREF().</tt> When a function passes ownership of a reference on to its caller, the caller is said to receive a new reference. When no ownership is  transferred, the caller is said to <A NAMe="idx1073750798"></a>borrow the reference. Nothing needs to be done for a borrowed reference.<a nAME="idx1073750799"></A><a name="idx1073750800"></a><a name="idx1073750801"></a><a name="idx1073750802"></a><a nAme="idx1073750803"></A><a naMe="idx1073750804"></a><a nAme="idx1073750805"></a><A NAMe="idx1073750806"></a><a nAME="idx1073750807"></A></p>

							<p>Conversely, when calling a function passes it a reference to an object, there are two possibilities: The function <a nAME="idx1073750808"></A>steals a reference to the object, or it does not. Few functions steal references; the two notable exceptions are <a namE="idx1073750809"></A><A Name="idx1073750810"></a><tt class="monofont">PyList_SetItem()</tt> and <a name="idx1073750811"></a><a NamE="idx1073750812"></a><tt Class="monofont">PyTuple_SetItem(),</Tt> which steal a reference to the item (but not to the tuple or list into which the item is put). These functions were designed to steal a reference because of a common idiom for populating a tuple or list with newly created objects; for example, the code to create the tuple (1, 2, "three") could look similar to this (forget about error handling for the moment):</p>

							<pRE>
								
PyObject *t;
t = PyTuple_New(3);
PyTuple_SetItem(t, 0, PyInt_FromLong(1L));
PyTuple_SetItem(t, 1, PyInt_FromLong(2L));
PyTuple_SetItem(t, 2, PyString_FromString("three"));

							</PRe>

							<p>Incidentally, <tt CLASs="monofont">PyTuple_SetItem()</tt> is the only way to <a NAME="idx1073750813"></a><a naME="idx1073750814"></A><A name="idx1073750815"></a>set tuple items; <tt class="monofont">PySequence_SetItem()</tt> and <tt clasS="monofont">PyObject_SetItem()</tt> refuse to do this because tuples are an immutable data type. You should only use <Tt clAss="monofont">PyTuple_SetItem()</tt> for tuples that you are creating yourself.</P>

							<p>Equivalent code for <a nAME="idx1073750816"></A><a namE="idx1073750817"></A>populating a list can be written using <A Name="idx1073750818"></a><A NAMe="idx1073750819"></a><tt CLASs="monofont">PyList_New()</tt> and <tt class="monofont">PyList_SetItem().</tt> Such code can also use <a name="idx1073750820"></a><a nAme="idx1073750821"></A><tt cLass="monofont">PySequence_SetItem()</tT>; this illustrates the difference between the two (the extra <tt cLASS="monofont">Py_DECREF()</tt> calls):</p>

							<pRE>
								
PyObject *l, *x;
l = PyList_New(3);
x = PyInt_FromLong(1L);
PySequence_SetItem(l, 0, x); Py_DECREF(x);
x = PyInt_FromLong(2L);
PySequence_SetItem(l, 1, x); Py_DECREF(x);
x = PyString_FromString("three");
PySequence_SetItem(l, 2, x); Py_DECREF(x);

							</PRe>

							<p>You might find it strange that the recommended approach takes more code. However, in practice, you will rarely use these ways of creating and populating a tuple or list. There's a generic function, <a nAME="idx1073750822"></A><a namE="idx1073750823"></A><TT class="monofont">Py_BuildValue(),</tt> that can create most common objects from C values, directed by a format string. For example, the previous two blocks of code could be replaced by the following (which also takes care of the <a name="idx1073750824"></a><a name="idx1073750825"></a>error checking):</p>

							<Pre>
								
PyObject *t, *l;
t = Py_BuildValue("(iis)", 1, 2, "three");
l = Py_BuildValue("[iis]", 1, 2, "three");

							</Pre>

							<p>It is more common to use <A name="idx1073750826"></A><a naME="idx1073750827"></A><Tt claSS="monofont">PyObject_SetItem()</TT> and become friends with items whose references you are only borrowing, like arguments that were passed in to the function you are writing. In that case, their behavior regarding reference counts is much saner because you don't have to increment a reference count so you can give a reference away (have it be stolen). For example, this function <a namE="idx1073750828"></A><A Name="idx1073750829"></a><A NAMe="idx1073750830"></a>sets all items of a list (actually, any mutable sequence) to a given item:</p>

							<pre>
								
int set_all(PyObject *target, PyObject *item)
{
    int i, n;
    n = PyObject_Length(target);
    if (n &lt; 0)
        return -1;
    for (i = 0; i &lt; n; i++) {
        if (PyObject_SetItem(target, i, item) &lt; 0)
            return -1;
    }
    return 0;
}

							</pre>

							<p>The situation is slightly different for function return values. Although <a name="idx1073750831"></a><a namE="idx1073750832"></a>passing a reference to most functions does not change your ownership responsibilities for that reference, many functions that return a reference to an object give you <a Name="idx1073750833"></A>ownership of  the reference. The reason is simple: In many cases, the returned object is created  on-the-fly, and the reference you get is the only reference to the object. Therefore, the generic functions that return object references, such as <a namE="idx1073750834"></a><a nAME="idx1073750835"></A><tt clASS="monofont">PyObject_GetItem()</Tt> and <a naME="idx1073750836"></A><A name="idx1073750837"></A><TT Class="monofont">PySequence_GetItem(),</tt> always return a new reference (that is, the caller becomes the owner of the reference).</p>

							<p>It is important to realize that whether you own a reference returned by a function only depends on which function you call—the plumage (that is, the type of the object passed as an argument to the function) doesn't enter into it. Thus, if you extract an item from a list using <tt class="monofont">PyList_GetItem(),</tt> you don't own the reference—but if you obtain the same item from the same list using <tt cLasS="monofont">PySequence_GetItem()</tt> (which happens to take exactly the same arguments), you do own a reference to the returned object.</p>

							<P>Here is an example of how you could write a function that computes the sum of the items in a list of integers; once using <a namE="idx1073750838"></a><a nAME="idx1073750839"></A><tt clASS="monofont">PyList_GetItem(),</Tt> once using <tt cLASS="monofont">PySequence_GetItem()</tt>:<a nAME="idx1073750840"></A><a name="idx1073750841"></a><a name="idx1073750842"></a><a name="idx1073750843"></a><a nAme="idx1073750844"></A><a naMe="idx1073750845"></a><a nAme="idx1073750846"></a><A NAMe="idx1073750847"></a><a nAME="idx1073750848"></A><a namE="idx1073750849"></A><A Name="idx1073750850"></a><A NAMe="idx1073750851"></a><a name="idx1073750852"></a><a name="idx1073750853"></a><a name="idx1073750854"></a></P>

							<prE>
								
long sum_list(PyObject *list)
{
    int i, n;
    long total = 0;



    PyObject *item;

   n = PyList_Size(list);
    if (n &lt; 0)
        return -1; /* Not a list */
    for (i = 0; i &lt; n; i++) {
        item = PyList_GetItem(list, i); /* Can't fail */
        if (!PyInt_Check(item)) continue; /* Skip non-integers */
        total += PyInt_AsLong(item);
    }
    return total;

}
long sum_sequence(PyObject *sequence)
{
    int i, n;
    long total = 0;
    PyObject *item;
    n = PyObject_Size(list);
    if (n &lt; 0)
        return -1; /* Has no length */
    for (i = 0; i &lt; n; i++) {
        item = PySequence_GetItem(list, i);
        if (item == NULL)
            return -1; /* Not a sequence, or other failure */
        if (PyInt_Check(item))
            total += PyInt_AsLong(item);
        Py_DECREF(item); /* Discard reference ownership */
    }
    return total;
}

							</pre>

						
					
					<H5>Types</h5>
						<p>Few other data types play a significant role in the Python/C API; most are simple C types such as int, long, double, and char *. A few structure types are used to describe static tables used to list the functions exported by a module or the data attributes of a new object type. These will be discussed together with the functions that use them.<a nAme="idx1073750855"></a><A NAMe="idx1073750856"></a><a nAME="idx1073750857"></A></p>

					
				
				<h4>Exceptions</h4>
					<p>The Python programmer only needs to deal with exceptions if specific error handling is required; unhandled exceptions are automatically propagated to the caller, and then to the caller's caller, and so on, until they reach the top-level interpreter, where they are reported to the user accompanied by a stack traceback.</P>

					<P>For C programmers, however, <A Name="idx1073750858"></a><A NAMe="idx1073750859"></a>error checking always has to be explicit. All functions in the Python/C API can raise exceptions, unless an explicit claim is made otherwise in a function's documentation. In general, when a function encounters an error, it sets an exception, discards any object references that it owns, and returns an error indicator—usually <tt class="monofont">NULL</tt> or <tt class="monofont">-1.</tt> A few functions return a Boolean <Tt cLass="monofont">true/false</Tt> result, with <tt cLass="monofont">false</TT> indicating an error. Very few functions return no explicit error indicator or have an ambiguous return value and require explicit testing for errors with <TT clasS="monofont">PyErr_Occurred()</TT><A name="idx1073750860"></A><A NAme="idx1073750861"></a><a NAME="idx1073750862"></a><a name="idx1073750863"></a><a name="idx1073750864"></a></p>

					<p><a name="idx1073750865"></A>Exception state is maintained in per-thread storage (this is equivalent to using global storage in an unthreaded application). A <a nAme="idx1073750866"></a><A name="idx1073750867"></A>thread can be in one of two states: An exception has occurred, or it hasn't. The function <a naME="idx1073750868"></A><Tt claSS="monofont">PyErr_Occurred()</TT> can be used to check for this: It returns a borrowed reference to the exception type object when an exception has occurred, and <tt clASS="monofont">NULL</Tt> otherwise. There are a number of functions to set the exception state: <a naME="idx1073750869"></A><A name="idx1073750870"></a><tt class="monofont">PyErr_SetString()</tt> is the most common (though not the most general) function to set the exception state, and <a name="idx1073750871"></a><A naMe="idx1073750872"></a><tT clasS="monofont">PyErr_Clear()</tt> clears the exception state.</p>

					<P>The full exception state consists of three objects (all of which can be <TT Class="monofont">NULL</TT>): the exception type, the corresponding exception value, and the traceback. These have the same meanings as the Python object <TT clasS="monofont">sys.exc_type,</TT>
						<Tt claSS="monofont">sys.exc_value,</TT>
						<tt class="monofont">sys.exc_traceback</tt>; however, they are not the same: The Python objects represent the last exception being handled by a Python <tt class="monofont">try ... except</tt> statement, whereas the C level exception state only exists while an exception is being passed on between C functions until it reaches the Python interpreter, which takes care of transferring it to <tt ClaSs="monofont">sys.exc_type</tt> and friends.</P>

					<p>Note that starting with Python 1.5, the preferred, thread-safe way to <a naMe="idx1073750873"></a>access the exception state from Python code is to call the function <a NAME="idx1073750874"></a><a naME="idx1073750875"></A><Tt claSS="monofont">sys.exc_info(),</TT> which returns the per-thread exception state for Python code. Also, the semantics of both ways to access the exception state have changed so that a function which catches an exception will save and restore its thread exception state to preserve the exception state of its caller. This prevents common bugs in exception handling code caused by an innocent- looking function overwriting the exception being handled; it also reduces the often unwanted lifetime extension for objects that are referenced by the stack frames in the traceback.</p>

					<p>As a general principle, a function that calls another function to perform some task should check whether the called function raised an exception, and if so, pass the exception state on to its caller. It should discard any object references that it owns, and returns an error indicator, but it should not set another exception—that would overwrite the exception just raised and lose important information about the exact cause of the error.<a nAME="idx1073750876"></A><a name="idx1073750877"></a><a name="idx1073750878"></a><a name="idx1073750879"></a><a nAme="idx1073750880"></A></p>

					<p>A simple example of <a Name="idx1073750881"></a><A namE="idx1073750882"></A><A Name="idx1073750883"></a><A NAMe="idx1073750884"></a>detecting exceptions and passing them on is shown in the previous <a nAME="idx1073750885"></A><a namE="idx1073750886"></A><TT class="monofont">sum_sequence()</tt> example. It so happens that the example doesn't need to clean up any owned references when it detects an error. The following example function shows some error cleanup. First, to remind you why you like Python, we show the equivalent Python code:</p>

					<pre>
						
def incr_item(dict, key):
    try:
        item = dict[key]
    except KeyError:
        item = 0
    return item + 1

					</pre>

					<p>Here is the corresponding C code, in all its glory:</p>

					<pre>
						
int incr_item(PyObject *dict, PyObject *key)
{
    /* Objects all initialized to NULL for Py_XDECREF */
    PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;
    int rv = -1; /* Return value initialized to -1 (failure) */
    item = PyObject_GetItem(dict, key);
    if (item == NULL) {
        /* Handle KeyError only: */
        if (!PyErr_ExceptionMatches(PyExc_KeyError)) goto error;
        /* Clear the error and use zero: */
        PyErr_Clear();
        item = PyInt_FromLong(0L);
        if (item == NULL) goto error;
    }
    const_one = PyInt_FromLong(1L);
    if (const_one == NULL) goto error;
    incremented_item = PyNumber_Add(item, const_one);
    if (incremented_item == NULL) goto error;

    if (PyObject_SetItem(dict, key, incremented_item) &lt; 0) goto error;
    rv = 0; /* Success */
    /* Continue with cleanup code */
 error:
    /* Cleanup code, shared by success and failure path */
    /* Use Py_XDECREF() to ignore NULL references */
    Py_XDECREF(item);
    Py_XDECREF(const_one);
    Py_XDECREF(incremented_item);
    return rv; /* -1 for error, 0 for success */
}

					</pRe>

					<p>This example represents an endorsed use of the goto statement in C. It illustrates the use of <Tt clAss="monofont">PyErr_ExceptionMatches()</tt> and <Tt clASS="monofont">PyErr_Clear()</Tt> to handle specific exceptions, and the use of <tt cLASS="monofont">Py_XDECREF()</tt> to dispose of owned references that might be <tt CLASs="monofont">NULL</tt> (note the X in the name; <tT CLAss="monofont">Py_DECREF()</tt> would crash when confronted with a <tt class="monofont">NULL</tt> reference). It is important that the variables used to hold owned references are initialized to <tt class="monofont">NULL</Tt> for this to work; likewise, the proposed return value is initialized to <tT claSs="monofont">-1</tt> (failure) and only set to success after the final call made is successful.<a Name="idx1073750887"></A><A NAme="idx1073750888"></a><a NAME="idx1073750889"></a><a naME="idx1073750890"></A><A name="idx1073750891"></A></P>

				
				<H4>Embedding Python</H4>
					<p>The one important task that only embedders (as opposed to extension writers) of the Python interpreter have to worry about is the initialization, and possibly the finalization, of the Python interpreter. Most functionality of the interpreter can only be used after the interpreter has been initialized.</p>

					<p>The basic initialization function is <a name="idx1073750892"></a><a name="idx1073750893"></a><tt claSs="monofont">Py_Initialize().</tT> This initializes the table of loaded modules and creates the fundamental modules <a naMe="idx1073750894"></a><a nAme="idx1073750895"></a><TT CLass="monofont">__builtin__,</tT>
						<A NAme="idx1073750896"></a><a NAME="idx1073750897"></a><tt cLASS="monofont">__main__,</tt> and <a name="idx1073750898"></a><a name="idx1073750899"></a><tt clasS="monofont">sys.</tt> It also initializes the module search path (<Tt clAss="monofont">sys.path</tt>).</P>

					<p><tt CLASs="monofont">Py_Initialize()</tt> does not set the script argument list (<tT CLAss="monofont">sys.argv</tt>). If this variable is needed by Python code that will be executed later, it must be set explicitly with a call to <TT CLass="monofont">PySys_SetArgv(argc, argv)</tT> subsequent to the call to <TT Class="monofont">Py_Initialize().</tt></p>

					<p>On most systems (in particular, on UNIX and Windows, although the details are slightly different), <tt class="monofont">Py_Initialize()</tt> calculates the module search path based on its best guess for the location of the standard Python interpreter executable, assuming that the Python library is found in a fixed location relative to the Python interpreter executable. In particular, it looks for a directory named lib/python1.5 (replacing 1.5 with the current interpreter version) relative to the parent directory where the executable named <tt cLasS="monofont">"python"</tt> is found on the shell command search path (the environment variable <tT clasS="monofont">$PATH</tt>).</p>

					<P>For instance, if the Python executable is found in <TT Class="monofont">/usr/local/bin/python,</TT> it will assume that the libraries are in <TT clasS="monofont">/usr/local/lib/python1.5.</TT> (In fact, this particular path is also the <A name="idx1073750900"></A><I>fallback</I> location, used when no executable file named <Tt class="monofont">"python"</tt> is found along <tt class="monofont">$PATH,</tt> unless some other prefix is set when <tt cLasS="monofont">configure</tt> is called.) The user can override this behavior by setting the environment variable <tT clasS="monofont">$PYTHONHOME,</tt> or insert additional directories in front of the standard path by setting <tT CLAss="monofont">$PYTHONPATH.</tt></P>

					<P>The embedding application can steer the search by calling <A Name="idx1073750901"></a><A NAMe="idx1073750902"></a><tt CLASs="monofont">Py_SetProgramName(file)</tt> before calling <tt class="monofont">Py_Initialize().</tt> Note that <tt class="monofont">$PYTHONHOME</tT> still overrides this and <tt ClasS="monofont">$PYTHONPATH</tt> is still inserted in front of the standard path. An application that requires total control has to provide its own implementation of <a nAme="idx1073750903"></a><A NAMe="idx1073750904"></a><tt CLASs="monofont">Py_GetPath(),</tt>
						<a NAME="idx1073750905"></a><a naME="idx1073750906"></A><Tt class="monofont">Py_GetPrefix(),</tt><a name="idx1073750907"></a><a name="idx1073750908"></a><Tt cLass="monofont">Py_GetExecPrefix(),</Tt> and <a naMe="idx1073750909"></a><a NAME="idx1073750910"></a><tt cLASS="monofont">Py_GetProgramFullPath()</tt> (all defined in <tt CLASs="monofont">Modules/ getpath.c</tt>).</p>

					<P>Sometimes, it is desirable to uninitialize Python. For instance, the application might want to start over (make another call to <TT Class="monofont">Py_Initialize()</tt>) or the application is simply done with its use of Python and wants to free all memory allocated by Python. This can be accomplished by calling <a name="idx1073750911"></a><a name="idx1073750912"></a><tt ClaSs="monofont">Py_Finalize().</tt> The function <A name="idx1073750913"></A><a naME="idx1073750914"></A><Tt claSS="monofont">Py_IsInitialized()</TT> returns <tt clASS="monofont">true</Tt> if Python is currently in the initialized state. More information about these functions is given in a later section. <a naME="idx1073750915"></A><A name="idx1073750916"></a><a name="idx1073750917"></a><a name="idx1073750918"></a><a naMe="idx1073750919"></a><A namE="idx1073750920"></a><a naMe="idx1073750921"></a></p>

				
			</FONT>
<P><TABLE width="100%" border=0><TR valign="top"><TD><font size=1 color="#C0C0C0"><br></font></TD><TD align=right><font size=1 color="#C0C0C0">Last updated on 1/30/2002<br>Python Developer's Handbook, &copy;&nbsp;2002 Sams Publishing</font></TD></TR></TABLE></P>
<TABLE border=0 width="100%" cellspacing=0 cellpadding=0><TR><td align=left width="15%" class="headingsubbarbg"><a href="256.html" title="A. Python/C API"><font size="1">&lt;&nbsp;BACK</font></a></td><td align=center width="70%" class="headingsubbarbg"><font size="1"><a href="popanote.asp?pubui=oreilly&bookname=0672319942&snode=257" target="_blank" title="Make a public or private annnotation">Make Note</a> | <a href="257.html" title="Use a Safari bookmark to remember this section">Bookmark</a></font></td><td align=right width="15%" class="headingsubbarbg"><a href="258.html" title="The Very High Level Layer"><font size="1">CONTINUE&nbsp;&gt;</font></a></td></TR></TABLE>
</TD></TR></TABLE>
<br><TABLE width=100% bgcolor=white border=0 cellspacing=0 cellpadding=5><TR><TD><H4 class=Title>Index terms contained in this section</H4>
<font size=2>
 <a href="#idx1073750894">__builtin__ module</a><BR>
 <a href="#idx1073750896">__main__ module</a><BR>
accessing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750873">exception states</a><BR>
Application Programmers Interface (API)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750765">Python/C</a> <a href="#idx1073750770">2nd</a> <a href="#idx1073750784">3rd</a> <a href="#idx1073750800">4th</a> <a href="#idx1073750841">5th</a> <a href="#idx1073750861">6th</a> <a href="#idx1073750877">7th</a> <a href="#idx1073750888">8th</a> <a href="#idx1073750916">9th</a><BR>
 <a href="#idx1073750798">borrowed references</a><BR>
checking<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750825">error</a> <a href="#idx1073750859">2nd</a><BR>
configuring<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750830">items in lists</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750815">tuples</a><BR>
counts<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reference<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750774">Python/C Application Programmers (API) interface</a> <a href="#idx1073750788">2nd</a> <a href="#idx1073750806">3rd</a> <a href="#idx1073750847">4th</a> <a href="#idx1073750857">5th</a><BR>
decrementing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750780">reference counts</a><BR>
embedding<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750918">Python/C Application Programmers Interface (API)</a><BR>
 <a href="#idx1073750824">error checking</a> <a href="#idx1073750858">2nd</a><BR>
exceptions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750849">finding</a> <a href="#idx1073750882">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750863">Python/C Application Programmers Interface (API)</a> <a href="#idx1073750879">2nd</a> <a href="#idx1073750890">3rd</a><BR>
 <a href="#idx1073750900">fallback location</a><BR>
files<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750768">header</a><BR>
finding<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750848">exceptions</a> <a href="#idx1073750881">2nd</a><BR>
functions<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750919">embedding Python</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750864">handling exceptions</a> <a href="#idx1073750880">2nd</a> <a href="#idx1073750891">3rd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750831">passing references to</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750823">Py_BuildValue()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750912">Py_Finalize()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750908">Py_GetExecPrefix()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750904">Py_GetPath()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750906">Py_GetPrefix()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750910">Py_GetProgramFullPath()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750893">Py_Initialize()</a> <a href="#idx1073750921">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750914">Py_IsInitialized()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750902">Py_SetProgramName(file)</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750872">PyErr_Clear()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750870">PyErr_SetString()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750839">PyList_GetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750819">PyList_New()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750809">PyList_SetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750835">PyObject_GetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750827">PyObject_SetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750837">PySequence_GetItem()</a> <a href="#idx1073750844">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750821">PySequence_SetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750812">PyTuple_SetItem()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750795">reference counts</a> <a href="#idx1073750807">2nd</a> <a href="#idx1073750854">3rd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750853">sum_sequence()</a> <a href="#idx1073750886">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750875">sys.exec_info()</a><BR>
 <a href="#idx1073750767">header files</a><BR>
incrementing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750790">reference counts</a> <a href="#idx1073750791">2nd</a><BR>
interfaces<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750766">Python/C Application Programmers (API)</a> <a href="#idx1073750771">2nd</a> <a href="#idx1073750785">3rd</a> <a href="#idx1073750801">4th</a> <a href="#idx1073750842">5th</a> <a href="#idx1073750862">6th</a> <a href="#idx1073750878">7th</a> <a href="#idx1073750889">8th</a> <a href="#idx1073750917">9th</a><BR>
lists<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750816">populating</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750829">setting items in</a><BR>
macros<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750778">Py_DECREF()</a> <a href="#idx1073750793">2nd</a> <a href="#idx1073750802">3rd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750776">Py_INCREF()</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750781">Py_XDECREF()</a> <a href="#idx1073750796">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750775">reference counts</a> <a href="#idx1073750789">2nd</a> <a href="#idx1073750792">3rd</a><BR>
modules<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750895">__builtin__</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750897">__main__</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750899">sys</a><BR>
object types<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750772">Python/C Application Programmers Interface (API)</a> <a href="#idx1073750786">2nd</a> <a href="#idx1073750804">3rd</a> <a href="#idx1073750845">4th</a> <a href="#idx1073750855">5th</a><BR>
 <a href="#idx1073750833">ownership, references</a><BR>
passing<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750851">exceptions</a> <a href="#idx1073750884">2nd</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750832">references to functions</a><BR>
populating<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750817">lists</a><BR>
 <a href="#idx1073750822">Py_BuildValue() function</a><BR>
 <a href="#idx1073750779">Py_DECREF() macro</a> <a href="#idx1073750794">2nd</a> <a href="#idx1073750803">3rd</a><BR>
 <a href="#idx1073750911">Py_Finalize() function</a><BR>
 <a href="#idx1073750907">Py_GetExecPrefix() function</a><BR>
 <a href="#idx1073750903">Py_GetPath() function</a><BR>
 <a href="#idx1073750905">Py_GetPrefix() function</a><BR>
 <a href="#idx1073750909">Py_GetProgramFullPath() function</a><BR>
 <a href="#idx1073750777">Py_INCREF() macro</a><BR>
 <a href="#idx1073750892">Py_Initialize() function</a> <a href="#idx1073750920">2nd</a><BR>
 <a href="#idx1073750913">Py_IsInitialized() function</a><BR>
 <a href="#idx1073750901">Py_SetProgramName(file) function</a><BR>
 <a href="#idx1073750782">Py_XDECREF() macro</a> <a href="#idx1073750797">2nd</a><BR>
 <a href="#idx1073750871">PyErr_Clear() function</a><BR>
 <a href="#idx1073750868">PyErr_Occurred() function</a><BR>
 <a href="#idx1073750869">PyErr_SetString() function</a><BR>
 <a href="#idx1073750838">PyList_GetItem() function</a><BR>
 <a href="#idx1073750818">PyList_New() function</a><BR>
 <a href="#idx1073750810">PyList_SetItem() function</a><BR>
 <a href="#idx1073750834">PyObject_GetItem() function</a><BR>
 <a href="#idx1073750826">PyObject_SetItem() function</a><BR>
 <a href="#idx1073750836">PySequence_GetItem() function</a> <a href="#idx1073750843">2nd</a><BR>
 <a href="#idx1073750820">PySequence_SetItem() function</a><BR>
 <a href="#idx1073750764">Python/C Application Programmers Interface (API)</a> <a href="#idx1073750769">2nd</a> <a href="#idx1073750783">3rd</a> <a href="#idx1073750799">4th</a> <a href="#idx1073750840">5th</a> <a href="#idx1073750860">6th</a> <a href="#idx1073750876">7th</a> <a href="#idx1073750887">8th</a> <a href="#idx1073750915">9th</a><BR>
 <a href="#idx1073750811">PyTuple_SetItem() function</a><BR>
reference counts<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750773">Python/C Application Programmers Interface (API)</a> <a href="#idx1073750787">2nd</a> <a href="#idx1073750805">3rd</a> <a href="#idx1073750846">4th</a> <a href="#idx1073750856">5th</a><BR>
searching<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750850">exceptions</a> <a href="#idx1073750883">2nd</a><BR>
setting<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750828">items in lists</a><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750813">typles</a><BR>
state<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750865">exceptions</a><BR>
states<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750867">thread</a><BR>
 <a href="#idx1073750808">stealing references</a><BR>
 <a href="#idx1073750852">sum_sequence() function</a> <a href="#idx1073750885">2nd</a><BR>
 <a href="#idx1073750898">sys module</a><BR>
 <a href="#idx1073750874">sys.exec_info() function</a><BR>
threads<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750866">states</a><BR>
tuples<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#idx1073750814">setting</a><BR>
<BR>
</font></TD></TR></TABLE>




<!--EndOfBrowse-->

</TD></TR></TABLE>
<table width=100% border=0 cellspacing=0 cellpadding=0 bgcolor=#990000><tr><td><p align=center><font size=1 face="verdana,arial,helvetica" color=white>© 2002, O'Reilly & Associates, Inc.</font></p></td></tr></table>
</BODY>
</HTML>